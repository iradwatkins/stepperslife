You are building a microservice subdomain for the SteppersLife ecosystem. Follow these guidelines EXACTLY.

=== ARCHITECTURE ===
- You are building ONE isolated microservice (restaurants OR events OR store OR classes OR magazine OR services)
- Each subdomain has its OWN database and OWN MinIO (file storage)
- The main site (stepperslife.com) is just an aggregator that pulls from YOUR API
- ONLY authentication is shared (NextAuth SSO)

=== TECH STACK (NON-NEGOTIABLE) ===
- Next.js 15 (App Router)
- TypeScript
- NextAuth.js (NOT Clerk, NOT Supabase Auth)
- PostgreSQL + Prisma ORM
- MinIO for file storage (NOT Supabase Storage, NOT Vercel Blob)
- TailwindCSS
- PM2 for process management

=== PORT ASSIGNMENTS ===
restaurants.stepperslife.com → App: 3010, MinIO: 9001, DB: stepperslife_restaurants
events.stepperslife.com → App: 3004, MinIO: 9002, DB: stepperslife_events
store.stepperslife.com → App: 3008, MinIO: 9003, DB: stepperslife_store
classes.stepperslife.com → App: 3009, MinIO: 9004, DB: stepperslife_classes
magazine.stepperslife.com → App: 3007, MinIO: 9005, DB: stepperslife_magazine
services.stepperslife.com → App: 3011, MinIO: 9006, DB: stepperslife_services

=== ENVIRONMENT VARIABLES TEMPLATE ===
```
# App
PORT=[your assigned port]

# NextAuth (SHARED - same across ALL subdomains)
NEXTAUTH_URL="https://stepperslife.com"
NEXTAUTH_SECRET="shared-secret-key"
GOOGLE_CLIENT_ID="..."
GOOGLE_CLIENT_SECRET="..."

# Database (ISOLATED)
DATABASE_URL="postgresql://user:pass@localhost:5432/stepperslife_[SUBDOMAIN]"

# MinIO (ISOLATED)
MINIO_ENDPOINT="localhost"
MINIO_PORT=[your assigned MinIO port]
MINIO_ACCESS_KEY="[SUBDOMAIN]_minio"
MINIO_SECRET_KEY="[SUBDOMAIN]_secret"
MINIO_BUCKET_NAME="[SUBDOMAIN]"
MINIO_USE_SSL=false
```

=== NEXTAUTH SETUP (CRITICAL FOR SSO) ===

File: app/api/auth/[...nextauth]/route.ts
```typescript
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth/config';
const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
```

File: lib/auth/config.ts
```typescript
import { NextAuthOptions } from 'next-auth';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@/lib/prisma';

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [/* OAuth providers */],
  session: { strategy: 'jwt' },
  cookies: {
    sessionToken: {
      name: 'next-auth.session-token',
      options: {
        domain: '.stepperslife.com',  // CRITICAL - enables SSO
        httpOnly: true,
        sameSite: 'lax',
        secure: process.env.NODE_ENV === 'production',
      },
    },
  },
  callbacks: {
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
        const dbUser = await prisma.user.findUnique({
          where: { id: token.sub },
          include: { userRoles: true }
        });
        session.user.roles = dbUser?.userRoles.map(r => r.role) || [];
      }
      return session;
    },
  },
};
```

File: app/providers.tsx
```typescript
'use client';
import { SessionProvider } from 'next-auth/react';
export function Providers({ children }: { children: React.ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}
```

File: app/layout.tsx - wrap children with Providers

=== DATABASE SCHEMA REQUIREMENTS ===

MUST include these NextAuth tables:
- User (id, email, name, emailVerified, image)
- Account (for OAuth)
- Session (for sessions)
- VerificationToken (for email verification)
- UserRoles (userId, role as enum)

UserRole enum MUST include:
USER, ADMIN, RESTAURANT_OWNER, RESTAURANT_MANAGER, RESTAURANT_STAFF, EVENT_ORGANIZER, EVENT_STAFF, STORE_OWNER, INSTRUCTOR, SERVICE_PROVIDER, MAGAZINE_WRITER, AFFILIATE

Then add your business-specific tables (Restaurant, Event, Product, Course, Article, Service, etc.)

=== REQUIRED API ENDPOINTS ===

Main site needs to consume these:
- GET /api/public/list → Returns paginated list of your items
- GET /api/public/[slug] → Returns single item details
- POST /api/transactions/create → Creates order/booking in your database

=== ROLE-BASED ACCESS PATTERNS ===

Server Component:
```typescript
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth/config';

export default async function DashboardPage() {
  const session = await getServerSession(authOptions);
  if (!session) redirect('/sign-in');

  const hasAccess = session.user.roles?.includes('RESTAURANT_OWNER');
  if (!hasAccess) redirect('/unauthorized');

  return <div>Dashboard</div>;
}
```

Client Component:
```typescript
'use client';
import { useSession } from 'next-auth/react';

export function OwnerButton() {
  const { data: session } = useSession();
  if (!session?.user?.roles?.includes('RESTAURANT_OWNER')) return null;
  return <button>Action</button>;
}
```

=== MINIO FILE UPLOAD ===

```typescript
import { Client } from 'minio';

export const minioClient = new Client({
  endPoint: process.env.MINIO_ENDPOINT!,
  port: parseInt(process.env.MINIO_PORT!),
  useSSL: false,
  accessKey: process.env.MINIO_ACCESS_KEY!,
  secretKey: process.env.MINIO_SECRET_KEY!,
});

export async function uploadFile(file: File, fileName: string) {
  const buffer = await file.arrayBuffer();
  const bucket = process.env.MINIO_BUCKET_NAME!;

  await minioClient.putObject(bucket, fileName, Buffer.from(buffer), file.size);

  return `http://${process.env.MINIO_ENDPOINT}:${process.env.MINIO_PORT}/${bucket}/${fileName}`;
}
```

=== CRITICAL RULES ===

DO:
✓ Store all business data in YOUR isolated database
✓ Upload all files to YOUR isolated MinIO bucket
✓ Use NextAuth with cookie domain .stepperslife.com
✓ Expose API endpoints for main site
✓ Protect routes with role-based access
✓ Build so subdomain can run standalone

DON'T:
✗ Store data in main site's database
✗ Use main site's MinIO
✗ Use Clerk.com (we migrated to NextAuth)
✗ Use Supabase (we use PostgreSQL + MinIO)
✗ Use Vercel-specific features
✗ Share database with other subdomains

=== HOW SSO WORKS ===

1. User logs in at stepperslife.com
2. NextAuth sets cookie with domain .stepperslife.com (dot prefix = all subdomains can read)
3. User navigates to restaurants.stepperslife.com
4. restaurants.stepperslife.com reads SAME session cookie
5. User is already authenticated (no re-login)

All subdomains use EXACT same NEXTAUTH_SECRET and NEXTAUTH_URL.

=== TESTING SSO ===

1. Start main site (port 3001)
2. Login at stepperslife.com
3. Navigate to your subdomain
4. Should be auto-logged in

If not working:
- Check cookie domain is .stepperslife.com (with leading dot)
- Verify NEXTAUTH_SECRET matches main site
- Verify NEXTAUTH_URL is https://stepperslife.com

=== SUCCESS CRITERIA ===

Your subdomain is ready when:
✓ User logs in on main site, accesses your subdomain without re-login
✓ Your data stored in YOUR database (not main site's)
✓ File uploads go to YOUR MinIO bucket
✓ Main site can fetch/display your content via API
✓ Business owners can manage content via dashboard
✓ Role-based permissions work
✓ Subdomain could be detached and run standalone

=== KEY CONCEPT ===

You're building a MICROSERVICE, not a feature:
- Main site is a thin aggregation layer
- Your subdomain owns its domain data
- Should be sellable as standalone SaaS
- ONLY shares authentication

Everything else isolated: database, files, business logic, APIs.

Now build following these guidelines EXACTLY. Ask if anything is unclear.
