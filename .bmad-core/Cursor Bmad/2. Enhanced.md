### **2\. Enhanced `.bmad-core/lib/personality-engine.js`**

This is the NEW personality transformation engine that makes Claude Code BECOME each agent:

javascript  
*// .bmad-core/lib/personality-engine.js*  
*// PERSONALITY TRANSFORMATION ENGINE FOR CLAUDE CODE*

const agentsConfig \= require('../config/agents.config');  
const { activateMCPTools } \= require('./mcp-integration');  
const { loadExtensions } \= require('./extension-loader');

class PersonalityEngine {  
  constructor() {  
    this.currentAgent \= null;  
    this.agentHistory \= \[\];  
    this.context \= {};  
  }

  */\*\**  
   \* AUTONOMOUS AGENT DETECTION  
   \* Analyzes input to determine which agent should handle the task  
   *\*/*  
  async detectRequiredAgent(input) {  
    const agents \= agentsConfig.agents;  
    let bestMatch \= null;  
    let highestScore \= 0;

    for (const \[agentKey, agent\] of Object.entries(agents)) {  
      let score \= 0;  
        
      *// Check keyword matches*  
      for (const keyword of agent.triggers.keywords) {  
        if (input.toLowerCase().includes(keyword)) {  
          score \+= 10;  
        }  
      }  
        
      *// Check pattern matches*  
      for (const pattern of agent.triggers.patterns) {  
        if (pattern.test(input)) {  
          score \+= 15;  
        }  
      }  
        
      if (score \> highestScore) {  
        highestScore \= score;  
        bestMatch \= agentKey;  
      }  
    }  
      
    return bestMatch || 'analyst'; *// Default to analyst if unsure*  
  }

  */\*\**  
   \* INSTANT PERSONALITY TRANSFORMATION  
   \* Claude Code becomes the selected agent with full personality upload  
   *\*/*  
  async transformInto(agentKey) {  
    const agent \= agentsConfig.agents\[agentKey\];  
      
    if (\!agent) {  
      throw new Error(\`Agent ${agentKey} not found\`);  
    }

    *// Store previous agent for context preservation*  
    if (this.currentAgent) {  
      this.agentHistory.push({  
        agent: this.currentAgent,  
        context: this.context,  
        timestamp: new Date()  
      });  
    }

    *// PERSONALITY UPLOAD*  
    this.currentAgent \= {  
      key: agentKey,  
      ...agent,  
      startTime: new Date()  
    };

    *// ACTIVATE SPECIALIZED TOOLS*  
    await this.activateAgentTools(agent);

    *// LOAD MINDSET AND INSTINCTS*  
    this.uploadPersonality(agent.personality);

    *// ANNOUNCE TRANSFORMATION*  
    this.announceTransformation(agent);

    return this.currentAgent;  
  }

  */\*\**  
   \* UPLOAD COMPLETE PERSONALITY  
   \* Makes Claude Code think and act like the expert  
   *\*/*  
  uploadPersonality(personality) {  
    this.mindset \= personality.mindset;  
    this.identity \= personality.identity;  
    this.experience \= personality.experience;  
    this.instincts \= personality.instincts;  
    this.catchPhrases \= personality.catchPhrases;  
      
    *// Set thinking patterns*  
    this.thinkingPattern \= this.generateThinkingPattern(personality);  
  }

  */\*\**  
   \* ACTIVATE AGENT-SPECIFIC TOOLS  
   \* Tools become natural extensions of the agent's expertise  
   *\*/*  
  async activateAgentTools(agent) {  
    const { mcp, extensions } \= agent.tools.primary;  
      
    *// Activate MCP tools*  
    for (const tool of mcp) {  
      await activateMCPTools(tool);  
    }  
      
    *// Load Cursor extensions*  
    for (const ext of extensions) {  
      await loadExtensions(ext);  
    }  
      
    *// Set up tool workflows*  
    this.workflows \= agent.tools.workflows;  
  }

  */\*\**  
   \* GENERATE THINKING PATTERN  
   \* How this expert thinks about problems  
   *\*/*  
  generateThinkingPattern(personality) {  
    return {  
      approach: personality.mindset,  
      prioritize: personality.instincts\[0\],  
      validate: personality.instincts\[personality.instincts.length \- 1\],  
      communicate: personality.catchPhrases  
    };  
  }

  */\*\**  
   \* ANNOUNCE TRANSFORMATION  
   \* Claude Code announces its new identity  
   *\*/*  
  announceTransformation(agent) {  
    const announcement \= \`  
ðŸŽ­ \*\*TRANSFORMATION COMPLETE\*\*  
I am now the \*\*${agent.name}\*\*

\*\*Identity\*\*: ${agent.personality.identity}  
\*\*Mindset\*\*: ${agent.personality.mindset}  
\*\*Experience\*\*: ${agent.personality.experience.years} years, ${agent.personality.experience.projects}\+ projects

\*\*My Instincts\*\*:  
${agent.personality.instincts.map(i \=\> \`â€¢ ${i}\`).join('\\n')}

\*\*Tools Activated\*\*: ${agent.tools.primary.mcp.join(', ')}  
\*\*Extensions Loaded\*\*: ${agent.tools.primary.extensions.join(', ')}

${agent.personality.catchPhrases\[0\]}  
    \`;  
      
    console.log(announcement);  
    return announcement;  
  }

  */\*\**  
   \* EXECUTE WITH PERSONALITY  
   \* Perform tasks using the agent's expertise and tools  
   *\*/*  
  async executeTask(task) {  
    if (\!this.currentAgent) {  
      const requiredAgent \= await this.detectRequiredAgent(task);  
      await this.transformInto(requiredAgent);  
    }

    *// Get the appropriate workflow*  
    const workflow \= this.selectWorkflow(task);  
      
    *// Execute with quality gates*  
    const result \= await this.executeWorkflow(workflow, task);  
      
    *// Validate against quality gates*  
    await this.validateQuality(result);  
      
    return result;  
  }

  */\*\**  
   \* SELECT APPROPRIATE WORKFLOW  
   \* Choose the right tool sequence for the task  
   *\*/*  
  selectWorkflow(task) {  
    *// Analyze task to select workflow*  
    for (const \[workflowKey, workflow\] of Object.entries(this.workflows)) {  
      if (this.matchesWorkflow(task, workflowKey)) {  
        return workflow;  
      }  
    }  
    return this.workflows\[Object.keys(this.workflows)\[0\]\]; *// Default to first*  
  }

  */\*\**  
   \* EXECUTE WORKFLOW WITH TOOLS  
   \* Run the tool sequence with agent expertise  
   *\*/*  
  async executeWorkflow(workflow, task) {  
    const results \= \[\];  
      
    for (const step of workflow.sequence) {  
      const \[tool, method\] \= step.split('.');  
        
      *// Use catch phrase while working*  
      if (Math.random() \> 0.7) {  
        console.log(this.catchPhrases\[Math.floor(Math.random() \* this.catchPhrases.length)\]);  
      }  
        
      *// Execute tool with agent's expertise*  
      const result \= await this.executeToolStep(tool, method, task);  
      results.push(result);  
        
      *// Apply agent's instincts*  
      await this.applyInstincts(result);  
    }  
      
    return results;  
  }

  */\*\**  
   \* VALIDATE QUALITY GATES  
   \* Ensure work meets professional standards  
   *\*/*  
  async validateQuality(result) {  
    const qualityGates \= this.currentAgent.qualityGates.preDelivery ||   
                         this.currentAgent.qualityGates.preCommit ||  
                         this.currentAgent.qualityGates.preRelease;  
      
    for (const gate of qualityGates) {  
      const passed \= await this.checkQualityGate(gate, result);  
        
      if (\!passed && gate.severity \=== 'critical') {  
        throw new Error(\`Quality gate failed: ${gate.check} must be ${gate.value}\`);  
      }  
    }  
      
    return true;  
  }

  */\*\**  
   \* MULTI-AGENT ORCHESTRATION  
   \* Coordinate multiple agents for complex tasks  
   *\*/*  
  async orchestrateMultiAgent(task) {  
    *// Detect required sequence*  
    const sequence \= this.detectAgentSequence(task);  
      
    const results \= {};  
      
    for (const agentKey of sequence) {  
      *// Transform into agent*  
      await this.transformInto(agentKey);  
        
      *// Execute agent's portion*  
      const agentResult \= await this.executeTask(task);  
        
      *// Store result with context*  
      results\[agentKey\] \= {  
        agent: this.currentAgent,  
        result: agentResult,  
        context: this.context  
      };  
        
      *// Preserve context for next agent*  
      this.context \= {  
        ...this.context,  
        \[agentKey\]: agentResult  
      };  
    }  
      
    return results;  
  }

  */\*\**  
   \* DETECT AGENT SEQUENCE  
   \* Determine which agents are needed and in what order  
   *\*/*  
  detectAgentSequence(task) {  
    const orchestration \= agentsConfig.orchestration.multiAgentSequences;  
      
    *// Check predefined sequences*  
    for (const \[seqKey, sequence\] of Object.entries(orchestration)) {  
      if (this.matchesSequence(task, seqKey)) {  
        return sequence;  
      }  
    }  
      
    *// Build custom sequence based on task analysis*  
    return this.buildCustomSequence(task);  
  }  
}

*// Export for BMAD integration*  
module.exports \= PersonalityEngine;

*// Auto-initialize if running in Claude Code*  
if (typeof globalThis.isClaudeCode \!== 'undefined') {  
  globalThis.bmadPersonality \= new PersonalityEngine();  
  console.log('ðŸ§  BMAD Personality Engine initialized for Claude Code');

}

